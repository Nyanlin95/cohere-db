# Memory & Checkpoint Patterns

> AUTO-GENERATED by cohere. Universal patterns with agent-specific notes.

## Directory Structure

```
.ai/
├── memory/
│   ├── checkpoints/          # Session checkpoints
│   │   └── checkpoint-{timestamp}.json
│   ├── accumulated-learnings.md  # Cross-session knowledge
│   ├── edge-cases.md         # Documented edge cases
│   └── session-history.md    # Recent session notes
```

---

## Checkpoint Pattern (Universal)

```typescript
interface AgentCheckpoint {
  timestamp: string;
  sessionId: string;
  schemaVersion: string;
  currentTask?: TaskContext;
  discoveredPatterns: DiscoveredPattern[];
  pendingQueries: PendingQuery[];
  agentMemory: Record<string, unknown>;
}

interface TaskContext {
  taskId: string;
  status: 'in_progress' | 'paused' | 'completed';
  lastAction?: string;
  progress: number;
}
```

### Save Checkpoint (Universal)
```typescript
import * as fs from 'fs/promises';
import * as path from 'path';

async function saveCheckpoint(
  outputDir: string,
  checkpoint: AgentCheckpoint
): Promise<string> {
  const filename = `checkpoint-${Date.now()}.json`;
  const filepath = path.join(outputDir, 'memory', 'checkpoints', filename);
  
  await fs.mkdir(path.dirname(filepath), { recursive: true });
  await fs.writeFile(filepath, JSON.stringify(checkpoint, null, 2));
  
  return filepath;
}
```

### Restore Checkpoint (Universal)
```typescript
async function restoreLatestCheckpoint(
  outputDir: string
): Promise<AgentCheckpoint | null> {
  const checkpointsDir = path.join(outputDir, 'memory', 'checkpoints');
  
  try {
    const files = await fs.readdir(checkpointsDir);
    const checkpointFiles = files
      .filter(f => f.startsWith('checkpoint-') && f.endsWith('.json'))
      .sort();
    
    if (checkpointFiles.length === 0) {
      return null;
    }
    
    const latest = checkpointFiles[checkpointFiles.length - 1];
    const filepath = path.join(checkpointsDir, latest);
    const content = await fs.readFile(filepath, 'utf-8');
    
    return JSON.parse(content) as AgentCheckpoint;
  } catch (error) {
    return null;
  }
}
```

---

> [!NOTE|CLAUDE]
> **CLAUDE CODE**: Built-in memory hooks available
> - `claude mem save <content>` - Save to memory
> - `claude mem list` - List memories
> - Auto-loads `~/.Claude/CLAUDE.md` for user-level persistence
> - Checkpoints integrate with `claude session restore`

> [!NOTE|CODEX]
> **CODEX CRITICAL**: No auto-memory persistence
> - MUST explicitly save checkpoints
> - MUST explicitly restore at session start:
>   ```
>   Read the .ai/memory/checkpoints directory. Find the latest checkpoint and restore context.
>   ```
> - AGENTS.md is NOT auto-loaded (see constraints.md)

> [!NOTE|ANTIGRAVITY]
> **ANTIGRAVITY**: Checkpoint coordination for parallel agents
> - Share checkpoints via shared storage
> - Use naming: `checkpoint-{agentId}-{timestamp}.json`
> - Lock files to prevent race conditions

> [!NOTE|XCODE]
> **XCODE 26.3**: Different persistence model
> - Use `ProjectDescription.plist` for project context
> - Use `.xcuserdatad` for user-specific state
> - Swift PM plugins don't persist across IDE sessions

---

## Session Handoff Pattern

```typescript
interface SessionHandoff {
  fromSession: string;
  toSession: string;
  timestamp: string;
  context: {
    schemaHash: string;
    pendingActions: string[];
    discoveredRelationships: string[];
    importantConstraints: string[];
  };
  summary: string;
}

async function createHandoff(
  outputDir: string,
  handoff: SessionHandoff
): Promise<void> {
  const handoffPath = path.join(outputDir, 'memory', 'handoff.json');
  
  await fs.writeFile(handoffPath, JSON.stringify(handoff, null, 2));
}
```

---

## Usage Examples

### Claude Code
```bash
# Auto-save to memory
claude mem save "Key pattern discovered: Use organization_id for tenant isolation"

# Manual checkpoint
npm run checkpoint:save
```

### Codex
```bash
# MUST be explicit
codex exec "node -e 'import(\"./memory/checkpoint\").then(m => m.saveCheckpoint(\".ai\", {...}))'"
```

### Antigravity (Parallel)
```bash
# Agent A
checkpoint:save --agent=a --shared=/shared/memory/

# Agent B
checkpoint:restore --agent=b --shared=/shared/memory/
```

---

## Best Practices (All Agents)

| Practice | Why |
|----------|-----|
| Checkpoint every 5-10 min | Prevent context loss |
| Include schema hash | Detect schema drift |
| Track pending queries | Resume incomplete work |
| Document discoveries | Accumulate knowledge |

---

## Cross-Session Learning

```typescript
interface LearnedPattern {
  timestamp: string;
  category: 'query' | 'schema' | 'relationship' | 'edge-case';
  description: string;
  sqlExample?: string;
  usageCount: number;
}

async function accumulateLearning(
  outputDir: string,
  learning: LearnedPattern
): Promise<void> {
  const memoryPath = path.join(outputDir, 'memory', 'accumulated-learnings.md');
  
  const newEntry = `
## ${learning.timestamp}

**Category:** ${learning.category}

**Description:** ${learning.description}

${learning.sqlExample ? `**Example:**
\`\`\`sql
${learning.sqlExample}
\`\`\`` : ''}

**Usage Count:** ${learning.usageCount}
`;
  
  const existing = await fs.readFile(memoryPath, 'utf-8').catch(() => '');
  await fs.writeFile(memoryPath, existing + newEntry);
}
```

---
*Pattern version: 1.0.1*
